"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("../errors");
const slider_1 = require("../math/slider");
const spline_1 = require("../math/spline");
const vector_1 = require("../math/vector");
const additions_1 = require("./additions");
const structs_1 = require("./structs");
const constants = require("../constants");
let additionTypes = [null, "normal", "soft", "drum"];
class HitObject {
    constructor(FadeTime, NewCombo, Hitsound, StartTime, EndTime, Position, EndPosition) {
        this.FadeTime = FadeTime;
        this.NewCombo = NewCombo;
        this.Hitsound = Hitsound;
        this.StartTime = StartTime;
        this.EndTime = EndTime;
        this.Position = Position;
        this.EndPosition = EndPosition;
        this.StackHeight = 0;
        this.ComboNumber = 0;
        this.Parent = null;
    }
    static parseEdgeAdditions(str) {
        let sample = null, additions = null;
        let parts = str.split(":");
        if (parts[0] && parts[0] !== "0")
            sample = parseInt(parts[0]);
        if (parts[1] && parts[1] !== "0")
            additions = parseInt(parts[1]);
        if (sample == null || additions == null)
            return null;
        return { sample, additions };
    }
    static parse(line) {
        let fadeTime = 0;
        let spline = null;
        let startTime, endTime;
        let curveType = 0;
        let parts = line.split(",");
        let soundType = parseInt(parts[4]);
        let objectType = parseInt(parts[3]);
        let i;
        startTime = endTime = parseInt(parts[2]);
        let soundTypes = [];
        let newCombo = (objectType & 4) == 4;
        let position = new vector_1.default(parseInt(parts[0]), parseInt(parts[1]));
        let customColor = (objectType >>> 4) & 7;
        if ((objectType & 1) == 1) {
            let hitsound = additions_1.default.parse(parts[5]);
            return new HitCircle(fadeTime, newCombo, hitsound, startTime, endTime, position, position);
        }
        else if ((objectType & 2) == 2) {
            let repeatCount = parseInt(parts[6]);
            let pixelLength = parseFloat(parts[7]);
            let hitsound = additions_1.default.parse(parts[10]);
            let controlPoints = [position];
            let points = (parts[5] || "").split("|");
            if (points.length) {
                switch (points[0]) {
                    case "L":
                        curveType = structs_1.CurveType.Linear;
                        spline = spline_1.Spline.linear(controlPoints, pixelLength);
                        break;
                    case "C":
                        curveType = structs_1.CurveType.Catmull;
                        break;
                    case "B":
                        curveType = structs_1.CurveType.Bezier;
                        spline = spline_1.Spline.bezier(controlPoints, pixelLength);
                        break;
                    case "P":
                        curveType = structs_1.CurveType.Perfect;
                        spline = spline_1.Spline.perfect(controlPoints, pixelLength);
                        break;
                }
                for (i = 1; i < points.length; i += 1) {
                    let coordinates = points[i].split(":");
                    controlPoints.push(new vector_1.default(parseInt(coordinates[0]), parseInt(coordinates[1])));
                }
            }
            if (spline == null)
                throw new Error(`Could not calculate spline for '${line}'.`);
            let endPosition = slider_1.default.GetEndPoint(curveType, pixelLength, controlPoints);
            if (endPosition == null)
                throw new Error(`Could not determine end position for '${line}'.`);
            return new Slider(fadeTime, newCombo, hitsound, startTime, endTime, position, endPosition, curveType, controlPoints, spline, pixelLength, repeatCount);
        }
        else if ((objectType & 8) == 8) {
            endTime = parseInt(parts[5]);
            let hitsound = additions_1.default.parse(parts[6]);
            return new Spinner(fadeTime, newCombo, hitsound, startTime, endTime, position, position);
        }
        throw new errors_1.ParseError(`Bad object type ${objectType}`);
    }
}
exports.HitObject = HitObject;
class HitCircle extends HitObject {
    FlipVertical() { this.Position.y = 384 - this.Position.y; }
}
exports.HitCircle = HitCircle;
class Slider extends HitObject {
    constructor(FadeTime, NewCombo, Hitsound, StartTime, EndTime, Position, EndPosition, CurveType, ControlPoints, Spline, PixelLength, RepeatCount) {
        super(FadeTime, NewCombo, Hitsound, StartTime, EndTime, Position, EndPosition);
        this.CurveType = CurveType;
        this.ControlPoints = ControlPoints;
        this.Spline = Spline;
        this.PixelLength = PixelLength;
        this.RepeatCount = RepeatCount;
    }
    Calculate() {
        if (this.Parent == null)
            return;
        let timing = this.Parent.GetTimingPoint(this.StartTime);
        if (timing) {
            let pxPerBeat = this.Parent.Config.SliderMultiplier * 100 * timing.Velocity;
            let beatsNumber = (this.PixelLength * this.RepeatCount) / pxPerBeat;
            let duration = Math.ceil(beatsNumber * timing.BeatLength);
            this.EndTime = this.StartTime + duration;
        }
        let spline;
        switch (this.CurveType) {
            case structs_1.CurveType.Linear:
                spline = spline_1.Spline.linear(this.ControlPoints, this.PixelLength);
                break;
            case structs_1.CurveType.Bezier:
                spline = spline_1.Spline.bezier(this.ControlPoints, this.PixelLength);
                break;
            case structs_1.CurveType.Perfect:
                spline = spline_1.Spline.perfect(this.ControlPoints, this.PixelLength);
                break;
        }
        this.EndPosition = this.Spline.points[this.Spline.points.length - 1];
    }
    FlipVertical() {
        for (let i = 0; i < this.ControlPoints.length; ++i)
            this.ControlPoints[i].y = 384 - this.ControlPoints[i].y;
    }
}
exports.Slider = Slider;
class Spinner extends HitObject {
    FlipVertical() { }
}
exports.Spinner = Spinner;
//# sourceMappingURL=hitObject.js.map