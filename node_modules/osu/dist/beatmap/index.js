"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const color_1 = require("../color");
const errors_1 = require("../errors");
const utils_1 = require("../utils");
const hitObject_1 = require("./hitObject");
const timingPoint_1 = require("./timingPoint");
const sectionPattern = /^\[([a-zA-Z0-9]+)\]$/, keyPairPattern = /^([a-zA-Z0-9]+)[ ]*:[ ]*(.+)?$/;
class Beatmap {
    constructor(FileFormat, Config, BpmMin = 0, BpmMax = Infinity, Difficulty, Bookmarks, HitObjects, TimingPoints) {
        this.FileFormat = FileFormat;
        this.Config = Config;
        this.BpmMin = BpmMin;
        this.BpmMax = BpmMax;
        this.Difficulty = Difficulty;
        this.Bookmarks = Bookmarks;
        this.HitObjects = HitObjects;
        this.TimingPoints = TimingPoints;
        this.MaxCombo = 0;
        this.ReactionTime = 0;
        this.ComboColors = [];
        this.Tags = [];
    }
    static parse(file) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!fs_1.existsSync(file)) {
                throw new Error("File doesn't exist.");
            }
            let data = yield utils_1.readFileAsync(file);
            return Beatmap.parseString(data.toString());
        });
    }
    static parseString(data) {
        return __awaiter(this, void 0, void 0, function* () {
            let i;
            let lines = data.split(/\r?\n/);
            let fileFormat = -1;
            let osuSection;
            let sections = {};
            let parseBookmark = (bookmark) => {
                return parseInt(bookmark);
            };
            let prev = null;
            let bpmMin = 0;
            let bpmMax = Infinity;
            let stackLeniency = 0;
            let distanceSpacing = 0;
            let sliderMultiplier = 0;
            let beatDivisor = 0;
            let sliderTickRate = 0;
            let gridSize = 0;
            let previewTime = 0;
            let mode = 0;
            let comboNumber = 0;
            let comboColor = 0;
            let maxCombo = 0;
            let tags = [];
            let bookmarks = [];
            let hitObjects = [];
            let timingPoints = [];
            let comboColors = [];
            let approachRate = 0, circleSize = 0, hpDrain = 0, overallDiff = 0;
            for (i = 0; i < lines.length; i += 1) {
                let line = lines[i].trim();
                if (!line)
                    continue;
                let match = sectionPattern.exec(line);
                if (match) {
                    osuSection = match[1].toLowerCase();
                    continue;
                }
                switch (osuSection) {
                    case "timingpoints":
                        let timingPoint = timingPoint_1.default.parse(line);
                        if (timingPoint instanceof timingPoint_1.UninheritedTimingPoint) {
                            bpmMin = Math.min(bpmMin, timingPoint.BPM);
                            bpmMax = Math.max(bpmMax, timingPoint.BPM);
                            timingPoint.BaseOffset = timingPoint.Offset;
                        }
                        else if (prev) {
                            timingPoint.BeatLength = prev.BeatLength;
                            timingPoint.BPM = prev.BPM;
                            timingPoint.BaseOffset = prev.BaseOffset;
                        }
                        prev = timingPoint;
                        timingPoints.push(timingPoint);
                        break;
                    case "hitobjects":
                        let hitObject = hitObject_1.HitObject.parse(line);
                        if (i == 0 || hitObject.NewCombo) {
                            comboNumber = 1;
                        }
                        else {
                            comboNumber += 1;
                            maxCombo = Math.max(maxCombo, comboNumber);
                        }
                        hitObject.ComboNumber = comboNumber;
                        hitObjects.push(hitObject);
                        break;
                    case "events":
                        break;
                    default:
                        if (!osuSection) {
                            match = /^osu file format (v[0-9]+)$/.exec(line);
                            if (match) {
                                fileFormat = parseInt(match[1]);
                                continue;
                            }
                        }
                        else {
                            match = keyPairPattern.exec(line);
                            if (match) {
                                if (!match[2])
                                    match[2] = "";
                                if (/combo(\d+)/i.exec(match[1])) {
                                    comboColors.push(color_1.default.fromArray(match[2].split(",").map(x => parseInt(x))));
                                    continue;
                                }
                                switch (match[1].toLowerCase()) {
                                    case "tags":
                                        tags = match[2].split(" ");
                                        break;
                                    case "bookmarks":
                                        bookmarks = match[2].split(",").map(x => parseInt(x));
                                        break;
                                    case "hpdrainrate":
                                        hpDrain = parseFloat(match[2]);
                                        break;
                                    case "circlesize":
                                        circleSize = parseFloat(match[2]);
                                        break;
                                    case "approachrate":
                                        approachRate = parseFloat(match[2]);
                                        break;
                                    case "overalldifficulty":
                                        overallDiff = parseFloat(match[2]);
                                        break;
                                    case "stackleniency":
                                        stackLeniency = parseFloat(match[2]);
                                        break;
                                    case "distancespacing":
                                        distanceSpacing = parseFloat(match[2]);
                                        break;
                                    case "slidermultiplier":
                                        sliderMultiplier = parseFloat(match[2]);
                                        break;
                                    case "beatdivisor":
                                        beatDivisor = parseFloat(match[2]);
                                        break;
                                    case "gridsize":
                                        gridSize = parseInt(match[2]);
                                        break;
                                    case "previewtime":
                                        previewTime = parseInt(match[2]);
                                        break;
                                    case "mode":
                                        mode = parseInt(match[2]);
                                        break;
                                    case "slidertickrate":
                                        sliderTickRate = parseInt(match[2]);
                                        break;
                                    default:
                                        throw new errors_1.ParseError(`Unknown field '${match[1]}'.`);
                                }
                            }
                        }
                        break;
                }
            }
            let difficulty = { ApproachRate: approachRate, CircleSize: circleSize, HPDrainRate: hpDrain, OverallDifficulty: overallDiff };
            let metadata = { Tags: tags };
            let config = {
                StackLeniency: stackLeniency,
                DistanceSpacing: distanceSpacing,
                SliderMultiplier: sliderMultiplier,
                SliderTickRate: sliderTickRate,
            };
            timingPoints.sort(function (a, b) { return a.Offset - b.Offset; });
            hitObjects.sort(function (a, b) { return a.StartTime - b.StartTime; });
            let beatmap = new Beatmap(fileFormat, config, bpmMin, bpmMax, difficulty, bookmarks, hitObjects, timingPoints);
            beatmap.HitObjects.map(x => x.Parent = beatmap);
            return beatmap;
        });
    }
    UpdateStacking(start = 0, end = -1) {
        const STACK_LENIENCE = 3;
        let nObj = this.HitObjects.length;
        while (end < 0)
            end += nObj;
        let stackThreshold = this.ReactionTime * this.Config.StackLeniency;
        for (let i = end; i >= start; --i)
            this.HitObjects[i].StackHeight = 0;
        let extEnd = end;
        for (let i = end; i >= start; --i) {
            let stackBase = i;
            for (let n = stackBase + 1; n < nObj; ++n) {
                let stackBaseObj = this.HitObjects[stackBase];
                if (stackBaseObj instanceof hitObject_1.Spinner)
                    break;
                let objN = this.HitObjects[n];
                if (objN instanceof hitObject_1.Spinner)
                    continue;
                if (objN.StartTime - stackBaseObj.EndTime > stackThreshold)
                    break;
                if (stackBaseObj.Position.distanceTo(objN.Position) < STACK_LENIENCE ||
                    (stackBaseObj instanceof hitObject_1.Slider && stackBaseObj.EndPosition.distanceTo(objN.Position) < STACK_LENIENCE)) {
                    stackBase = n;
                    this.HitObjects[n].StackHeight = 0;
                }
            }
            if (stackBase > extEnd) {
                extEnd = stackBase;
                if (extEnd == nObj - 1)
                    break;
            }
        }
        let extStart = start;
        for (let i = extEnd; i > start; --i) {
            let n = i;
            if (this.HitObjects[i].StackHeight != 0 || this.HitObjects[i] instanceof hitObject_1.Spinner)
                continue;
            let j = i;
            if (this.HitObjects[i] instanceof hitObject_1.HitCircle) {
                while (--n >= 0) {
                    let objN = this.HitObjects[n];
                    if (objN instanceof hitObject_1.Spinner)
                        continue;
                    if (this.HitObjects[j].StartTime - objN.EndTime > stackThreshold)
                        break;
                    if (n < extStart) {
                        this.HitObjects[n].StackHeight = 0;
                        extStart = n;
                    }
                    if (objN instanceof hitObject_1.Slider && objN.EndPosition.distanceTo(this.HitObjects[j].Position) < STACK_LENIENCE) {
                        let offset = this.HitObjects[j].StackHeight - objN.StackHeight + 1;
                        for (let j = n + 1; j <= i; ++j) {
                            let objJ = this.HitObjects[j];
                            if (objN.EndPosition.distanceTo(objJ.Position) < STACK_LENIENCE)
                                objJ.StackHeight -= offset;
                        }
                        break;
                    }
                    if (objN.Position.distanceTo(this.HitObjects[j].Position) < STACK_LENIENCE) {
                        this.HitObjects[n].StackHeight = this.HitObjects[j].StackHeight + 1;
                        j = n;
                    }
                }
            }
            else if (this.HitObjects[i] instanceof hitObject_1.Slider) {
                while (--n >= start) {
                    let objN = this.HitObjects[n];
                    if (objN instanceof hitObject_1.Spinner)
                        continue;
                    if (this.HitObjects[j].StartTime - objN.EndTime > stackThreshold)
                        break;
                    if (objN.EndPosition.distanceTo(this.HitObjects[j].Position) < STACK_LENIENCE) {
                        this.HitObjects[n].StackHeight = this.HitObjects[j].StackHeight + 1;
                        j = n;
                    }
                }
            }
        }
    }
    GetTimingPoint(offset) {
        let left = 0, right = this.TimingPoints.length - 1;
        let result = 0;
        while (left <= right) {
            let midpoint = ~~((left + right) / 2);
            if (this.TimingPoints[midpoint].Offset > offset) {
                right = midpoint - 1;
            }
            else {
                result = midpoint;
                left = midpoint + 1;
            }
        }
        return this.TimingPoints[result];
    }
    GetIndexAt(offset) {
        let i;
        for (i = 0; i < this.HitObjects.length; i++) {
            let obj = this.HitObjects[i];
            if (obj instanceof hitObject_1.Slider || obj instanceof hitObject_1.Spinner) {
                if (offset < obj.EndTime)
                    return i;
            }
            else {
                if (offset <= obj.StartTime)
                    return i;
            }
        }
        return i - 1;
    }
}
exports.Beatmap = Beatmap;
//# sourceMappingURL=index.js.map