"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const structs_1 = require("../beatmap/structs");
const vector_1 = require("./vector");
class SliderMath {
    static GetCircumCircle(p1, p2, p3) {
        let x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, x3 = p3.x, y3 = p3.y;
        let D = 2 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2));
        let Ux = ((x1 * x1 + y1 * y1) * (y2 - y3) + (x2 * x2 + y2 * y2) * (y3 - y1) + (x3 * x3 + y3 * y3) * (y1 - y2)) / D;
        let Uy = ((x1 * x1 + y1 * y1) * (x3 - x2) + (x2 * x2 + y2 * y2) * (x1 - x3) + (x3 * x3 + y3 * y3) * (x2 - x1)) / D;
        let center = new vector_1.default(Ux, Uy);
        let r = center.distanceTo(new vector_1.default(x1, y1));
        return [center, r];
    }
    static GetEndPoint(curveType, sliderLength, points) {
        switch (curveType) {
            case structs_1.CurveType.Linear:
                return SliderMath.PointOnLine(points[0], points[1], sliderLength);
            case structs_1.CurveType.Bezier:
                throw new Error("unimplemented");
            case structs_1.CurveType.Perfect:
                if (!points || points.length < 2)
                    return null;
                if (points.length == 2)
                    return SliderMath.PointOnLine(points[0], points[1], sliderLength);
                if (points.length > 3)
                    return SliderMath.GetEndPoint(structs_1.CurveType.Bezier, sliderLength, points);
                let [circumCenter, radius] = SliderMath.GetCircumCircle(points[0], points[1], points[2]);
                let radians = sliderLength / radius;
                if (SliderMath.IsLine(points[0], points[1], points[2]))
                    radians *= -1;
                return SliderMath.Rotate(circumCenter, points[1], radians);
            case structs_1.CurveType.Catmull:
            default:
                return null;
        }
    }
    static IsLine(a, b, c) {
        return ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) == 0;
    }
    static PointOnLine(p1, p2, length) {
        let fullLength = p1.distanceTo(p2);
        let n = fullLength - length;
        let x = (n * p1.x + length * p2.x) / fullLength;
        let y = (n * p1.y + length * p2.y) / fullLength;
        return new vector_1.default(x, y);
    }
    static Rotate(center, point, angle) {
        let nx = Math.cos(angle), ny = Math.sin(angle);
        return new vector_1.default(nx * (point.x - center.x) - ny * (point.y - center.y) + center.x, ny * (point.x - center.x) + nx * (point.y - center.y) + center.y);
    }
}
exports.default = SliderMath;
//# sourceMappingURL=slider.js.map