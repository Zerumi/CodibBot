"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const slider_1 = require("./slider");
const vector_1 = require("./vector");
const constants = require("../constants");
class Spline {
    constructor(control, length) {
        this.control = control;
        this.length = length;
        this.pxLength = 0;
        this.lengthMap = [];
        this.points = [];
    }
    static bezier(control, length) {
        if (control.length == 2)
            return Spline.linear(control, length);
        return new BezierSpline(control, length);
    }
    static linear(control, length) {
        if (control.length != 2)
            throw new Error("Linear slider with the wrong number of control points (expected: 2, got: " + control.length + ")");
        return new LinearSpline(control, length);
    }
    static perfect(control, length) {
        if (control.length != 3)
            throw new Error("Perfect slider with the wrong number of control points (expected: 3, got: " + control.length + ")");
        if (slider_1.default.IsLine(control[0], control[1], control[2]))
            return Spline.linear([control[0], control[1]], length);
        return new PerfectSpline(control, length);
    }
    calculate() {
        this.pxLength = 0;
        this.lengthMap = new Array();
        this.lengthMap.push(0);
        for (let i = 1; i < this.points.length; ++i) {
            let segmentDistance = this.points[i].distanceTo(this.points[i - 1]);
            this.pxLength += segmentDistance;
            this.lengthMap.push(this.pxLength);
        }
    }
    pointAt(progress) {
        let i, distancePercent = 0;
        for (i = 1; i < this.lengthMap.length; ++i) {
            distancePercent = 1.0 * this.lengthMap[i] / this.pxLength;
            if (progress == distancePercent)
                return this.points[i];
            if (progress < distancePercent)
                break;
        }
        let pi = Math.max(0, i - 1);
        let left = this.points[pi];
        let right = this.points[i];
        let segmentPercent = (this.lengthMap[i] - this.lengthMap[pi]) / this.pxLength;
        let p = (distancePercent - progress) / segmentPercent;
        return new vector_1.default(right.x - p * (right.x - left.x), right.y - p * (right.y - left.y));
    }
}
exports.Spline = Spline;
class BezierApproximator {
    constructor(control) {
        this.control = control;
        this.subdivBuf1 = [];
        this.subdivBuf2 = [];
    }
    static isFlatEnough(curve) {
        for (let i = 1; i < curve.length - 1; ++i) {
            if ((curve[i - 1].sub(curve[i].smul(2)).add(curve[i + 1])).m2 > constants.bezierTolerance)
                return false;
        }
        return true;
    }
    subdivide(points, left, right) {
        let midpoints = this.subdivBuf1;
        for (let i = 0; i < this.control.length; ++i)
            midpoints[i] = points[i];
        for (let i = 0; i < this.control.length; ++i) {
            left[i] = midpoints[0];
            right[this.control.length - i - 1] = midpoints[this.control.length - i - 1];
            for (let j = 0; j < this.control.length - i - 1; ++j)
                midpoints[j] = midpoints[j].add(midpoints[j + 1]).smul(0.5);
        }
    }
    approximate(points, output) {
        let left = this.subdivBuf2;
        let right = this.subdivBuf1;
        this.subdivide(points, left, right);
        for (let i = 0; i < this.control.length - 1; ++i)
            left[this.control.length + i] = right[i + 1];
        output.push(points[0]);
        for (let i = 1; i < this.control.length - 1; ++i) {
            let index = 2 * i;
            let p = left[index - 1].add(left[index].smul(2)).add(left[index + 1]).smul(0.25);
            output.push(p);
        }
    }
    calculate() {
        let output = [];
        let toFlatten = [this.control.slice(0)];
        let freeBuffers = [];
        let leftChild = this.subdivBuf2;
        while (toFlatten.length > 0) {
            let parent = toFlatten.pop();
            if (parent == undefined)
                break;
            if (BezierApproximator.isFlatEnough(parent)) {
                this.approximate(parent, output);
                freeBuffers.push(parent);
                continue;
            }
            let rightChild;
            let tmp;
            if ((tmp = freeBuffers.pop()) != undefined)
                rightChild = tmp;
            else
                rightChild = Array(this.control.length);
            this.subdivide(parent, leftChild, rightChild);
            for (let i = 0; i < this.control.length; ++i)
                parent[i] = leftChild[i];
            toFlatten.push(rightChild);
            toFlatten.push(parent);
        }
        output.push(this.control[this.control.length - 1]);
        return output;
    }
}
class BezierSpline extends Spline {
    constructor(points, length) {
        super(points, length);
        let lastIndex = 0;
        for (let i = 0; i < points.length; ++i) {
            let multipart = i < points.length - 2 && points[i].equals(points[i + 1]);
            if (multipart || i == points.length - 1) {
                let segment = points.slice(lastIndex, i + 1);
                if (segment.length == 2) {
                    this.points.push(points[lastIndex]);
                    this.points.push(points[i]);
                }
                else {
                    let bezier = new BezierApproximator(segment);
                    let points = bezier.calculate();
                    for (let j = 0; j < points.length; ++j)
                        this.points.push(points[j]);
                }
                if (multipart)
                    i++;
                lastIndex = i;
            }
        }
        this.calculate();
    }
}
exports.BezierSpline = BezierSpline;
class LinearSpline extends Spline {
    constructor(points, length) {
        super(points, length);
        this.points.push(points[0]);
        let unit = points[1].sub(points[0]).norm();
        this.points.push(points[0].add(unit.smul(length)));
        this.calculate();
    }
}
exports.LinearSpline = LinearSpline;
class PerfectSpline extends Spline {
    constructor(points, length) {
        super(points, length);
        let [center, radius] = slider_1.default.GetCircumCircle(points[0], points[1], points[2]);
        let t0 = Math.atan2(center.y - points[0].y, points[0].x - center.x);
        let t1 = Math.atan2(center.y - points[2].y, points[2].x - center.x);
        let mid = Math.atan2(center.y - points[1].y, points[1].x - center.x);
        while (mid < t0)
            mid += 2 * Math.PI;
        while (t1 < t0)
            t1 += 2 * Math.PI;
        if (mid > t1)
            t1 -= 2 * Math.PI;
        let direction = (t1 - t0) / Math.abs(t1 - t0);
        let nt1 = t0 + direction * (length / radius);
        for (let t = t0; nt1 >= t0 ? t < nt1 : t > nt1; t += (nt1 - t0) / length) {
            let rel = new vector_1.default(Math.cos(t) * radius, -Math.sin(t) * radius);
            this.points.push(center.add(rel));
        }
        this.calculate();
    }
}
exports.PerfectSpline = PerfectSpline;
//# sourceMappingURL=spline.js.map